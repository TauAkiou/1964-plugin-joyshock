/*
 *==========================================================================
 * Joyshock Injector - 1964 Plugin
 *==========================================================================
 * Largely based off of the original Keyboard/Mouse Injector Plugin
 * Copyright (C) 2016-2021 Carnivorous
 *
 * Joyshock Injector
 * Copyright (C) 2016-2021 TauAkiou
 * All rights reserved.
 *
 * Joyshock Injector is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License as published by the Free
 * Software Foundation; either version 2 of the License, or (at your option)
 * any later version.
 *
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
 * or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License
 * for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, visit http://www.gnu.org/licenses/gpl-2.0.html
 *==========================================================================
 */

    if(_link->ReadInt(GE_menupage) < 1) // hacks can only be injected at boot sequence before code blocks are cached, so inject until the main menu
        _injecthacks();
    /*
    const int camera = _link->ReadInt(GE_camera);
    const int exit = _link->ReadInt(GE_exit);
    const int pause = _link->ReadInt(GE_pause);
    const int menupage = _link->ReadInt(GE_menupage);
    const int tankflag = _link->ReadInt(GE_tankflag);
    const int mproundend = _link->ReadInt(GE_matchended);
    */
    for(int player = PLAYER1; player < ALLPLAYERS; player++)
    {
        if(_settings->Profile[player].QuickConfigSetting == DISABLED) // bypass disabled players
            continue;


        if(!_settings->Profile[player].FreeAiming) {
            _processOriginalAimmode(player);
        }
        else if(_settings->Profile[player].FreeAiming) {
            _processFreeAim(player);
        }
        /*

        vec2<float> aimstickdata = _ihandler.ProcessAimStickInputForPlayer((PLAYERS)player);

        playerbase[player] = BONDDATA(player);
        const int dead = _link->ReadInt(playerbase[player] + GE_deathflag);
        const int watch = _link->ReadInt(playerbase[player] + GE_watch);
        const int aimingflag = _link->ReadInt(playerbase[player] + GE_aimingflag);
        const int mppausemenu = _link->ReadInt(playerbase[player] + GE_multipausemenu);
        const int cursoraimingflag = _settings->Profile[player].GoldeneyeAimMode && aimingflag;
        const float fov = _link->ReadFloat(playerbase[player] + GE_fov);
        const float basefov = fov > 60.0f ? (float)OVERRIDEFOV : 60.0f;
        //const float mouseaccel = _settings->Profile[player].SETTINGS[ACCELERATION] ? sqrt(_cfgptr->Device[player].XPOS * _cfgptr->Device[player].XPOS + _cfgptr->Device[player].YPOS * _cfgptr->Device[player].YPOS) / TICKRATE / 12.0f * _settings->Profile[player].SETTINGS[ACCELERATION] : 0;
        const float sensitivity_stick_x = _settings->Profile[player].AimStickSensitivity.x / 40.0f;// * fmax(mouseaccel, 1);
        const float sensitivity_stick_y = _settings->Profile[player].AimStickSensitivity.y / 40.0f; // * fmax(mouseaccel, 1);

        const float sensitivity_stick_menu_x = 100 / 40.0f;
        const float sensitivity_stick_menu_y = 100 / 40.0f;


        const float sensitivity_gyro_x = _settings->Profile[player].GyroscopeSensitivity.x / 40.0f;
        const float sensitivity_gyro_y = _settings->Profile[player].GyroscopeSensitivity.y / 40.0f; // fmax(mouseaccel, 1);

        const float gunsensitivity_stick_x = sensitivity_stick_x * (_settings->Profile[player].Crosshair / 2.5f);
        const float gunsensitivity_stick_y = sensitivity_stick_y * (_settings->Profile[player].Crosshair / 2.5f);
        const float gunsensitivity_gyro_x = sensitivity_gyro_x * (_settings->Profile[player].Crosshair / 2.5f);
        const float gunsensitivity_gyro_y = sensitivity_gyro_y * (_settings->Profile[player].Crosshair / 2.5f);

        float camx = _link->ReadFloat(playerbase[player] + GE_camx), camy = _link->ReadFloat(playerbase[player] + GE_camy);
        if(camx >= 0 && camx <= 360 && camy >= -90 && camy <= 90 && fov >= 1 && fov <= FOV_MAX && dead == 0 && watch == 0 && pause == 0 && (camera == 4 || camera == 0) && exit == 1 && menupage == 11 && !mproundend && !mppausemenu) // if safe to inject
        {
            _aimmode(player, cursoraimingflag, fov, basefov);
            if(!tankflag) // player is on foot
            {
                _crouch(player); // only allow crouching if player is not in tank
                if(!cursoraimingflag) { // if not aiming (or geaimmode is off)
                    camx += aimstickdata.x / 10.0f * sensitivity_stick_x *
                            (fov / basefov); // regular mouselook calculation
                    camx += _cfgptr->Device[player].GYRO.x / 10.0f * sensitivity_gyro_x * _cfgptr->DeltaTime * (fov / basefov);
                }
                else
                    camx += aimx[player] * (fov / basefov); // scroll screen with aimx/aimy
                while(camx < 0)
                    camx += 360;
                while(camx >= 360)
                    camx -= 360;
                _link->WriteFloat(playerbase[player] + GE_camx, camx);
            }
            else // player is in tank
            {
                GE_ResetCrouchToggle(player); // reset crouch toggle if in tank
                float tankx = _link->ReadFloat(GE_tankxrot);
                if(!cursoraimingflag || _link->ReadInt(playerbase[player] + GE_currentweapon) == 32) { // if not aiming (or geaimmode is off) or player is driving tank with tank equipped as weapon, then use regular mouselook calculation
                    tankx += aimstickdata.x / 10.0f * sensitivity_stick_x / (360 / TANKXROTATIONLIMIT * 2.5) *
                             (fov / basefov);
                    tankx += _cfgptr->Device[player].GYRO.x / 10.0f * sensitivity_gyro_x / (360 / TANKXROTATIONLIMIT * 2.5) *
                             _cfgptr->DeltaTime * (fov / basefov);
                }
                else
                    tankx += aimx[player] / (360 / TANKXROTATIONLIMIT * 2.5) * (fov / basefov);
                while(tankx < 0)
                    tankx += TANKXROTATIONLIMIT;
                while(tankx >= TANKXROTATIONLIMIT)
                    tankx -= TANKXROTATIONLIMIT;
                _link->WriteFloat(GE_tankxrot, tankx);
            }
            if(!cursoraimingflag) {
                camy += (!_settings->Profile[player].PitchInverted ? -aimstickdata.y : aimstickdata.y) /
                        10.0f * sensitivity_stick_y * (fov / basefov);
                camy += (!_settings->Profile[player].PitchInverted ? -_cfgptr->Device[player].GYRO.y : _cfgptr->Device[player].GYRO.y) /
                        10.0f * sensitivity_gyro_y * _cfgptr->DeltaTime * (fov / basefov);
            }
            else
                camy += -aimy[player] * (fov / basefov);
            camy = PluginHelpers::ClampFloat(camy, tankflag ? -20 : -90, 90); // tank limits player from looking down -20
            _link->WriteFloat(playerbase[player] + GE_camy, camy);
            if(_settings->Profile[player].Crosshair && !cursoraimingflag) // if crosshair movement is enabled and player isn't aiming (don't calculate weapon movement while the player is in aim mode)
            {
                if(!tankflag)
                {
                    float gunx = _link->ReadFloat(playerbase[player] + GE_gunx), crosshairx = _link->ReadFloat(playerbase[player] + GE_crosshairx); // after camera x and y have been calculated and injected, calculate the gun/crosshair movement
                    gunx += aimstickdata.x / (!aimingflag ? 10.0f : 40.0f) * gunsensitivity_stick_x * (fov / basefov) * 0.019f;
                    gunx += _cfgptr->Device[player].GYRO.x / (!aimingflag ? 10.0f : 40.0f) * gunsensitivity_gyro_x * _cfgptr->DeltaTime * (fov / basefov) * 0.019f;
                    crosshairx += aimstickdata.x / (!aimingflag ? 10.0f : 40.0f) * gunsensitivity_stick_x * (fov / 4 / (basefov / 4)) * 0.01912f / RATIOFACTOR;
                    crosshairx += _cfgptr->Device[player].GYRO.x / (!aimingflag ? 10.0f : 40.0f) * gunsensitivity_gyro_x * (fov / 4 / (basefov / 4)) * _cfgptr->DeltaTime * 0.01912f / RATIOFACTOR;
                    if(aimingflag) // emulate cursor moving back to the center
                        gunx /= _settings->EmulatorOverclocked ? 1.03f : 1.07f, crosshairx /= _settings->EmulatorOverclocked ? 1.03f : 1.07f;
                    gunx = PluginHelpers::ClampFloat(gunx, -GUNAIMLIMIT, GUNAIMLIMIT);
                    crosshairx = PluginHelpers::ClampFloat(crosshairx, -CROSSHAIRLIMIT, CROSSHAIRLIMIT);
                    _link->WriteFloat(playerbase[player] + GE_gunx, gunx);
                    _link->WriteFloat(playerbase[player] + GE_crosshairx, crosshairx);
                }
                if((!tankflag && camy > -90 || tankflag && camy > -20) && camy < 90) // only allow player's gun to pitch within a valid range
                {
                    float guny = _link->ReadFloat(playerbase[player] + GE_guny), crosshairy = _link->ReadFloat(playerbase[player] + GE_crosshairy);
                    guny += (!_settings->Profile[player].PitchInverted ? aimstickdata.y : -aimstickdata.y) / (!aimingflag ? 40.0f : 20.0f) * gunsensitivity_stick_y * (fov / basefov) * 0.025f;
                    guny += (!_settings->Profile[player].PitchInverted ? _cfgptr->Device[player].GYRO.y : -_cfgptr->Device[player].GYRO.y) / (!aimingflag ? 40.0f : 20.0f) * gunsensitivity_gyro_y * (fov / basefov) * 0.025f;
                    crosshairy += (!_settings->Profile[player].PitchInverted ? aimstickdata.y : -aimstickdata.y) / (!aimingflag ? 40.0f : 20.0f) * gunsensitivity_stick_y * (fov / 4 / (basefov / 4)) * 0.0225f;
                    crosshairy += (!_settings->Profile[player].PitchInverted ? _cfgptr->Device[player].GYRO.x : -_cfgptr->Device[player].GYRO.y) / (!aimingflag ? 40.0f : 20.0f) * gunsensitivity_gyro_y * _cfgptr->DeltaTime * (fov / 4 / (basefov / 4)) * 0.0225f;
                    if(aimingflag)
                        guny /= _settings->EmulatorOverclocked ? 1.15f : 1.35f, crosshairy /= _settings->EmulatorOverclocked ? 1.15f : 1.35f;
                    guny = PluginHelpers::ClampFloat(guny, -GUNAIMLIMIT, GUNAIMLIMIT);
                    crosshairy = PluginHelpers::ClampFloat(crosshairy, -CROSSHAIRLIMIT, CROSSHAIRLIMIT);
                    _link->WriteFloat(playerbase[player] + GE_guny, guny);
                    _link->WriteFloat(playerbase[player] + GE_crosshairy, crosshairy);
                }
                */